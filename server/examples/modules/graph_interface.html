<!DOCTYPE html>
<!-- 
Project Name: SPIKE Prime Web Interface
File name: graph_interface.html
Author: Jeremy Jung
Last update: 7/7/20
Description: module to be loaded into service dock example that enables graphing of sensor data
* this module can be only run with servicedock_index.html *
Credits/inspirations:
    Based on UJSONRPC Web Serial by Ethan Danahy, Olga Sans
History: 
    Created by Jeremy on 6/25/20
LICENSE: MIT
(C) Tufts Center for Engineering Education and Outreach (CEEO)
-->
<script src = "./libraries/UJSONRPClib.js" type = "text/javascript"></script>
<script src = "./libraries/hoverscript_jquery.js" type = "text/javascript"></script>
<script src = "./libraries/jquery_351.js" type = "text/javascript"></script>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<head>
    <script src="https://cdn.plot.ly/plotly-latest.js" charset="utf-8"></script>
</head>
<body>
    <div id = "graphbox">
        <div id = "selectbox" class = "target_ignore"> 
            <select id = "portSelect" class = "select_components target_ignore" onchange = change_dataSelect()>
                <option id = "A">A</option>
                <option id = "B">B</option>
                <option id = "C">C</option>
                <option id = "D">D</option>
                <option id = "E">E</option>
                <option id = "F">F</option>
            </select>
            <select id = "dataSelect" class = "select_components target_ignore" onchange = graph_it()></select>
        </div>
        <div id="chart"></div>
    </div>
</body>

<script>

        // parse information about devices connected to the ports
        async function ports_to_options() {

            // get device info with functions from UJSONRPClib
            ports = await get_devices();
            value = await retrieve_data();

            var parsed;
            try { 
                parsed = await JSON.parse(value);
            }
            catch (error) {
                console.log(value);
            }

            data = await parsed.p;
            
            var index_to_port = ["A","B","C","D","E","F"];
            //parse connected devices' readings
            for ( var key = 0; key < 6; key++ ) {
                letter = index_to_port[key];
                device_type = ports[letter];

                //populate the options in portSelect (in grapher.html)
                $("#" + letter).text(device_type + "(" + letter + ")");

            }
        }

        //get sensor information 
        async function graph_it() {

            var index_to_port = ["A","B","C","D","E","F"];

            //get hub connected devices' information (a dictionary)
            ports = await get_devices();

            //parse ujson for useful data
            value = await retrieve_data();
            parsed = await JSON.parse(value);
            data = await parsed.p;

            //get ids of selected port and data to display
            var selected_port = $("#portSelect option:selected").attr('id');
            var selected_data = $("#dataSelect option:selected").attr('id');
            
            //find the port letter
            var letter;
            for ( var key = 0; key < 6; key++ ) {
                if (index_to_port[key] == selected_port) {
                    letter = index_to_port[key];
                    break;
                }
            }

            //get the type of device
            device_type = ports[letter];
            //collect the y variable to graph
            var data_to_graph = 0;
            switch (selected_data) {
                case "graphMspeed":
                    data_to_graph =  await data[key][1][0];
                    break;
                case "graphMangle":
                    data_to_graph =  await data[key][1][1];
                    break;
                case "graphMuangle":
                    data_to_graph =  await data[key][1][2];
                    break;
                case "graphMpower":
                    data_to_graph =  await data[key][1][3];
                    break;
                case "graphUdist":
                    data_to_graph = await data[key][1][0];
                    break;
                case "graphFamount":
                    data_to_graph = await data[key][1][0];
                    break;
                case "graphFbinary":
                    data_to_graph = await data[key][1][1];
                    break;
                case "graphFbigamount":
                    data_to_graph = await data[key][1][2];
                    break;
                case "graphCdist":
                    data_to_graph = await data[key][1][0];
                    break;  
                case "graphCunknown":
                    data_to_graph = await data[key][1][1];
                    break; 
                case "graphCg":
                    data_to_graph = await data[key][1][3];
                    break;  
                case "graphCr":
                    data_to_graph = await data[key][1][2];
                    break;
                case "graphCb":
                    data_to_graph = await data[key][1][4];
                    break;
                default:
                    break;
            }

            return data_to_graph
        }

        //initialize options of data to graph based on port/device selection
        async function change_dataSelect() {
            //get the device type
            var str_length = $("#portSelect option:selected").text().length
            var device_type = await $("#portSelect option:selected").text().substring(0,str_length-3); 

            //change options of available sensor data by device type
            if ( device_type == "Motor" ) {
                $("#dataSelect").empty();
                $("#dataSelect").append("<option id = 'graphMspeed'>speed</option>")
                $("#dataSelect").append("<option id = 'graphMangle'>angle</option>")
                $("#dataSelect").append("<option id = 'graphMuangle'>unit angle</option>")
                $("#dataSelect").append("<option id = 'graphMpower'>power</option>")
            }
            if ( device_type == "Ultrasonic" ) {
                $("#dataSelect").empty();
                $("#dataSelect").append("<option id = 'graphUdist'>distance</option>")
            }
            if ( device_type == "Force") {
                $("#dataSelect").empty();
                $("#dataSelect").append("<option id = 'graphFamount'>force</option>")
                $("#dataSelect").append("<option id = 'graphFbinary'>true/false</option>")
                $("#dataSelect").append("<option id = 'graphFbigamount'>precise force</option>")
            }
            if ( device_type == "Color" ) {
                $("#dataSelect").empty();
                $("#dataSelect").append("<option id = 'graphCdist'>distance</option>")
                $("#dataSelect").append("<option id = 'graphCunknown'>ambient light</option>")
                $("#dataSelect").append("<option id = 'graphCr'>Red</option>")
                $("#dataSelect").append("<option id = 'graphCg'>Green</option>")
                $("#dataSelect").append("<option id = 'graphCb'>Blue</option>")
            }
        }

        //sleep function
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // start graphing
        // Note: graphs every 15 miliseconds (ASYNC INTERVAL)
        $(function() {            
            Plotly.plot('chart',[{
                y:[graph_it()],
                type:'line'
            }]);
            
            var cnt = 0;
            setInterval(async function(){
                var datapoint;
                try {
                    datapoint = await graph_it()
                }
                catch (error) {

                }
                Plotly.extendTraces('chart',{ y:[[datapoint]]}, [0]);
                cnt++;
                if(cnt > 500) {
                    Plotly.relayout('chart',{
                        xaxis: {
                            range: [cnt-500,cnt]
                        }
                    });
                }
            },15);
        })

        //when DOM is ready
        $(document).ready( () => {
            console.log("grapher DOMContentLoaded");

            //checking if port was connected at the main UJSON interface
            var check_port_connection;
            var execute_once_flag = true;
            check_port_connection = setInterval( async () => {
                if (port_connected) {
                    //now that port is connected, there is no need to repeatedly check
                    clearInterval(check_port_connection);

                    //wait for a full json line to be read at data_stream
                    await sleep(3000);
                    
                    //populate the select tags with device information connected to the hub
                    await ports_to_options();

                    //execute once
                    if (execute_once_flag) {
                        await change_dataSelect();
                        execute_once_flag = false;
                    }
                }
            }, 100)

            //make the interface draggable
            dragElement("graphbox")

        })
</script>

<style>
    #graphbox {
        background-color: #4CE0D2;
        height: 600px;
        width: 400px;
        border: solid;
    }

    #chart {
        position: relative;
        top: 50px;
    }

    .select_components {
        height: 50px;
        width: 200px;
        font-size: 20px;
    }
</style>
